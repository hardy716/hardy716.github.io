---
layout: post
title: 스위프트의 타입 2
image: /assets/img/blog/swift/05/thumbnail05.png
accent_image: 
  background: url('/assets/img/sidebar/apple-park.png') center/cover
  overlay: false
accent_color: '#ccc'
theme_color: '#ccc'
description: >
  타입 선언, 타입 추론, 타입 안전성, 타입 변환에 대해 정리했습니다.
invert_sidebar: true
---

# 스위프트의 타입 2

* toc
{:toc}


## 📙 1. 타입 안전성

[이전 게시글 : 스위프트의 등장 배경과 언어적 특성](https://hardy716.github.io/blog/swift/2023-07-12-swift01/)에서 살펴볼 수 있듯이, 스위프트는 타입 안전성을 중요하게 여기는 언어이다.

스위프트에서는 런타임 에러를 방지하고 코드의 타입 안전성을 높이기 위한 방법으로, 스위프트 컴파일러가 컴파일 시점에 강력한 타입 검사와 타입 추론을 수행한다.

타입 안정성과 관련해서 스위프트 컴파일러는 다음과 같은 순서로 동작한다.

1. 문법 체크 : 먼저 문법적인 에러가 있는지 확인한다.

2. 타입 추론 : 초기값이 있는 변수나 상수에 대해서 타입을 추론한다.

3. 타입 검사 : 변수나 상수, 함수의 인자 등에서 예상되는 타입과 실제 타입이 일치하는지 검사한다.

4. 제어 흐름 분석 : 조건문, 반복문, 분기문 등의 제어 흐름을 분석하여, 각 분기에서의 타입이 일관성을 유지하는지 확인한다.

5. 함수와 메서드 호출 검사 : 함수나 메서드를 호출할 때 인자의 타입, 반환 타입이 일치하는지 확인한다.

6. 옵셔널 체크 : 옵셔널 타입의 값이 제대로 해제되었는지, 또는 안전하게 사용되고 있는지 체크한다.

7. 다운캐스팅 및 업캐스팅 검사 : 타입 캐스팅을 할 때, 해당 캐스팅이 유효한지 검사한다.


## 📙 2. 타입 추론

스위프트에서는 타입을 위한 제약 사항을 생성하면서 타입을 추론해낸다.

제약 사항은 쉽게 말해서 타입 관련 규칙이라고 할 수 있다.

이해를 돕기 위해 아래에 간단한 예시를 들어보려고 한다.

```swift
func add(a: Int, b: Int) -> Int {
    return a + b
}

let result = add(a: 1, b: 2)
```

위의 스위프트 코드는 `add` 함수를 정의하고, 해당 함수를 호출하여 그 결과를 `result`라는 상수에 저장하는 간단한 동작을 수행한다.

위 코드에서는 아래와 같은 제약 사항이 발생할 수 있다.

- `add` 함수는 `Int` 타입의 인자를 받고, `Int` 타입을 반환한다.

- `result` 변수는 `add` 함수의 반환 타입과 같은 타입이다.

두 개의 제약 사항으로부터 `result` 변수가 `Int` 타입임을 추론할 수 있는데,

이와 같이 스위프트에서는 제약 사항들을 생성하고, 이를 해결하면서 실제 타입 추론을 수행한다.

(참고로, 데이터 값이 문자인 경우 컴파일러는 Character가 아닌 String으로 타입을 유추한다.)

스위프트의 제약 사항과 관련해서 참고할 만한 글 - [Swift Internals- LLVM, Type system, Swift Foundation을 중심으로, 김 정님](https://academy.realm.io/kr/posts/swift-internals-llvm-type-system-swift-foundation/)이 있어서 시간이 된다면 읽어보는 것을 추천한다.


## 📙 3. 타입 주석 (타입 선언)

#### 1) 타입 주석

변수 또는 표현식의 타입을 명시적으로 지정하는 것을 타입 주석이라고 한다.

아래는 애플 공식 예제를 가져와서 약간 변형한 코드이다.

```swift
let someTuple: (Double, Double)
someTuple = (3.14159, 2.71828)
```

위 코드에서 상수 someTuple의 타입이 `(Double, Double)`로 명시적으로 지정된 것을 확인할 수 있다.

이처럼 변수 또는 표현식이 특정 타입으로 지정된 경우, 초기화하고자 할 때 지정된 데이터 타입의 값만 할당이 가능하다는 것에 주의해야 한다.

#### 2) 타입 주석이 있는 경우, 스위프트의 컴파일러

또한, 타입 주석의 유무에 따라서 컴파일러의 동작에 약간의 차이가 있다.

차이가 발생하는 지점은 2번, 3번이므로, 해당 부분만 타입 주석이 있을 때의 컴파일러 동작과 일치하도록 수정하면 아래와 같다.

2. 타입 주석 검사 : 타입 주석이 문법적으로 올바른지, 그리고 해당 타입이 유효한 타입인지 확인한다.

3. 초기값과 타입 일치 검사 : 만약 초기값이 주어졌다면, 초기값의 타입이 타입 주석과 일치하는지 확인한다.

#### 3) 타입 주석이 있는 경우, 제약 사항

타입 주석을 사용하는 경우에도 제약 사항은 생성된다. 다만, 컴파일러가 변수나 표현식의 타입을 명시적으로 알 수 있기 때문에, 타입 추론 과정은 생략된다.

따라서 일반적으로 타입 주석이 많을수록, 비교적 단순하고 명확한 제약 사항이 생성되기 때문에 컴파일 시간이 비교적 빨라진다고 할 수 있다.

(일반적인 상황에서 타입 주석의 유무가 컴파일 속도에 영향을 미치는 정도는 미미하다고 해도 무방하다. 그러나 복잡한 표현식이나 큰 데이터 구조에 사용되는 경우 유의미한 결과를 도출해낼 수도 있기 때문에 평소에 타입 주석을 사용하는 습관을 들이는 것을 추천한다.)


## 📙 4. 타입 변환

기존에 메모리에 저장된 값을 다른 형식으로 바꿔서 새로운 값을 생성하고, 이을 다른 메모리에 공간에 다시 저장하는 것을 타입 변환이라고 한다.

스위프트에서 기본 데이터 타입들 사이의 변환은 일반적으로 명시적인 생성자를 사용하여 수행한다.

```swift
let integer: Int = 37
let float: Float = Float(integer)
let double: Double = Double(integer)
```

단, 데이터가 변환이 되지 않거나 유실되는 경우도 있으므로 주의해야 한다. 

타입 변환에 실패한 경우, nil이 반환된다.

ex1) `Double` 타입 => `Int` 타입  :  소수점 버림 (데이터 유실)

ex2) `String` 타입("hardy") = X => `Int` 타입  :  데이터 변환 불가
